#! C:/Program Files/Nuke14.0v2/nuke-14.0.2.dll -nx
version 14.0 v2
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="0" y="0" w="1917" h="991" screen="0">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="1254" stretch="1"/>
            <splitter orientation="2">
                <split size="557"/>
                <dock id="" activePageId="Viewer.1">
                    <page id="Viewer.1"/>
                </dock>
                <split size="392"/>
                <dock id="" activePageId="DAG.1" focus="true">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                </dock>
            </splitter>
            <split size="615"/>
            <dock id="" activePageId="Properties.1">
                <page id="Properties.1"/>
                <page id="uk.co.thefoundry.backgroundrenderview.1"/>
                <page id="Scenegraph.1"/>
                <page id="Pixel Analyzer.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/Assignment1.nk"
 frame 47
 first_frame 46
 last_frame 50
 lock_range true
 format "2048 1556 0 0 2048 1556 1 2K_Super_35(full-ap)"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement Nuke
 workingSpaceLUT linear
 monitorLut sRGB
 monitorOutLUT rec709
 int8Lut sRGB
 int16Lut sRGB
 logLut Cineon
 floatLut linear
}
BackdropNode {
 inputs 0
 name MRF_2D
 tile_color 0x71c67100
 note_font_size 42
 xpos -150
 ypos -257
 bdwidth 297
 bdheight 287
}
BackdropNode {
 inputs 0
 name MRF_3D
 tile_color 0xc68824ff
 note_font_size 42
 xpos 160
 ypos -354
 bdwidth 392
 bdheight 386
}
BackdropNode {
 inputs 0
 name Motion_Compensation3D
 tile_color 0x8e388e00
 note_font_size 42
 xpos 685
 ypos -363
 bdwidth 491
 bdheight 336
}
Read {
 inputs 0
 file_type tiff
 file "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/Hula.#####.tiff"
 format "2048 1080 0 0 2048 1080 1 2K_DCP"
 first 46
 last 50
 origfirst 46
 origlast 50
 origset true
 colorspace linear
 name Read1
 xpos -140
 ypos -313
}
set N93840800 [stack 0]
Expression {
 expr0 "(r - 0.3217) *(r - 0.3217) /0.00193"
 expr1 "(g-0.6276) * (g-0.6276)/0.00021"
 expr2 "(b - 0.5150) * (b - 0.5150) / 0.000251"
 name BackgroundEnergy
 xpos -140
 ypos -177
}
Expression {
 expr0 "r + g + b"
 expr1 "r + g + b"
 expr2 "r + g + b"
 name BackgroundEnergySum
 xpos -140
 ypos -134
}
set N93841000 [stack 0]
Expression {
 temp_name0 threshold
 temp_expr0 70
 expr0 "step(threshold, r)"
 expr1 "step(threshold, r)"
 expr2 "step(threshold, r)"
 name ThresholdedEnergy
 xpos -140
 ypos -88
}
set N93841400 [stack 0]
Read {
 inputs 0
 file_type tiff
 file "C:/Users/mradt/Documents/Trinity/Binary-Matting/Hula.MLKey.  ##.tiff"
 format "2048 1080 0 0 2048 1080 1 2K_DCP"
 first 46
 last 50
 origfirst 46
 origlast 50
 origset true
 name Read2
 xpos -293
 ypos -209
}
BlinkScript {
 inputs 2
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/EqualsTo.blink"
 recompileCount 8
 ProgramGroup 1
 KernelDescription "2 \"EqualsTo\" iterate pixelWise bcd1be60cea15d2194548ece8f665c5b1fc4d609d87773aaf7743543845fc1e4 3 \"src\" Read Point \"ref\" Read Point \"dst\" Write Point 0 0 0"
 kernelSource "kernel EqualsTo: ImageComputationKernel<ePixelWise> \{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image (binary)\n  Image<eRead, eAccessPoint, eEdgeClamped> ref; // the reference image\n  // Checks if differences between two images is more than 1e6\n  // If it is .. that pel is coloured RED, otherwise its GREEN\n\n  Image<eWrite> dst; // the output image\n  \n  // pos gives the position of the kernel in the output image\n  void process(int2 pos) \{\n    SampleType(dst) sample(0.0f);\n    SampleType(src) input = src();\n    SampleType(ref) ref_input = ref();\n    float error = fabs(input.x - ref_input.x);\n                   + fabs(input.y - ref_input.y)\n                   + fabs(input.z - ref_input.z);\n    if (error >0.000001)\n      sample.x = 1.0f;\n    else\n      sample.y = 1.0f;\n\n    dst() = sample;\n  \}\n\};"
 rebuild ""
 rebuild_finalise ""
 name BlinkScript1
 xpos -293
 ypos -94
}
push $N93841400
Dot {
 name Dot7
 xpos -30
 ypos -85
}
set N9388e000 [stack 0]
push $N93841000
Dot {
 name Dot1
 xpos -11
 ypos -131
}
set N9388e400 [stack 0]
BlinkScript {
 inputs 2
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/MAP.rpp"
 recompileCount 98
 KernelDescription "2 \"MAP\" iterate pixelWise fd48645e1b4de5817c41d4e9dd78ad326a3255f342c03d4c0999d062c53eaedc 3 \"energy\" Read Random \"alpha\" Read Random \"dst_alpha\" Write Point 0 0 0"
 kernelSource "\nkernel MAP : ImageComputationKernel<ePixelWise>\n\{\n\n  Image<eRead, eAccessRandom, eEdgeClamped> energy; // the input background energy \n  Image<eRead, eAccessRandom, eEdgeClamped> alpha; // the referenced image\n\n\n  Image<eWrite> dst_alpha; // the output alpha\n\n\n  void process(int2 pos) \{\n    int x = pos.x;\n    int y = pos.y;\n\n    int numZeros = 0;\n    int numOnes = 0;\n    float lambda = 20.0f;\n    \n    // Calculate 3x3 neighborhood of pixels that say what we should be.\n    for(int i = -1; i < 2; i++) \{\n      for(int j = -1; j < 2; j++) \{\n        if(i == 0 && j == 0)\n        \{\n          continue;\n        \}\n        float4 vec = alpha(j + x,i + y);\n        // Since its a white or black pixel, accessing one of the color channels \n        // is sufficient to determine if \n        // foreground or background\n        if(vec.x == 1 || vec.y == 1 || vec.z == 1) \{\n            numOnes +=1;\n        \}\n        else\{\n            numZeros +=1;\n        \}\n      \}\n    \}\n\n    float E_t = 60;\n\n    float E0 = E_t + lambda * float(numZeros);\n\n    float E1 = energy(x,y).x + lambda * float(numOnes);\n\n    if(E0 > E1)\n    \{\n      dst_alpha() = float4(0.0f,0.0f,0.0f,1.0f);\n    \}\n    else \n    \{\n      dst_alpha() = float4(1.0f,1.0f,1.0f,1.0f);\n    \}\n  \}\n\};\n"
 rebuild ""
 rebuild_finalise ""
 name MAP
 xpos 57
 ypos -140
}
set N9388e800 [stack 0]
push $N9388e400
Dot {
 name Dot3
 xpos -11
 ypos -64
}
set N9388ec00 [stack 0]
BlinkScript {
 inputs 2
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/MAP.rpp"
 recompileCount 79
 KernelDescription "2 \"MAP\" iterate pixelWise fd48645e1b4de5817c41d4e9dd78ad326a3255f342c03d4c0999d062c53eaedc 3 \"energy\" Read Random \"alpha\" Read Random \"dst_alpha\" Write Point 0 0 0"
 kernelSource "\nkernel MAP : ImageComputationKernel<ePixelWise>\n\{\n\n  Image<eRead, eAccessRandom, eEdgeClamped> energy; // the input background energy \n  Image<eRead, eAccessRandom, eEdgeClamped> alpha; // the referenced image\n\n\n  Image<eWrite> dst_alpha; // the output alpha\n\n\n  void process(int2 pos) \{\n    int x = pos.x;\n    int y = pos.y;\n\n    int numZeros = 0;\n    int numOnes = 0;\n    float lambda = 20.0f;\n    \n    // Calculate 3x3 neighborhood of pixels that say what we should be.\n    for(int i = -1; i < 2; i++) \{\n      for(int j = -1; j < 2; j++) \{\n        if(i == 0 && j == 0)\n        \{\n          continue;\n        \}\n        float4 vec = alpha(j + x,i + y);\n        // Since its a white or black pixel, accessing one of the color channels \n        // is sufficient to determine if \n        // foreground or background\n        if(vec.x == 1 || vec.y == 1 || vec.z == 1) \{\n            numOnes +=1;\n        \}\n        else\{\n            numZeros +=1;\n        \}\n      \}\n    \}\n\n    float E_t = 60;\n\n    float E0 = E_t + lambda * float(numZeros);\n\n    float E1 = energy(x,y).x + lambda * float(numOnes);\n\n    if(E0 > E1)\n    \{\n      dst_alpha() = float4(0.0f,0.0f,0.0f,1.0f);\n    \}\n    else \n    \{\n      dst_alpha() = float4(1.0f,1.0f,1.0f,1.0f);\n    \}\n  \}\n\};\n"
 rebuild ""
 rebuild_finalise ""
 name MAP1
 xpos 57
 ypos -78
}
set N9388f000 [stack 0]
push $N9388ec00
Dot {
 name Dot2
 xpos -11
 ypos 2
}
BlinkScript {
 inputs 2
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/MAP.rpp"
 recompileCount 77
 KernelDescription "2 \"MAP\" iterate pixelWise fd48645e1b4de5817c41d4e9dd78ad326a3255f342c03d4c0999d062c53eaedc 3 \"energy\" Read Random \"alpha\" Read Random \"dst_alpha\" Write Point 0 0 0"
 kernelSource "\nkernel MAP : ImageComputationKernel<ePixelWise>\n\{\n\n  Image<eRead, eAccessRandom, eEdgeClamped> energy; // the input background energy \n  Image<eRead, eAccessRandom, eEdgeClamped> alpha; // the referenced image\n\n\n  Image<eWrite> dst_alpha; // the output alpha\n\n\n  void process(int2 pos) \{\n    int x = pos.x;\n    int y = pos.y;\n\n    int numZeros = 0;\n    int numOnes = 0;\n    float lambda = 20.0f;\n    \n    // Calculate 3x3 neighborhood of pixels that say what we should be.\n    for(int i = -1; i < 2; i++) \{\n      for(int j = -1; j < 2; j++) \{\n        if(i == 0 && j == 0)\n        \{\n          continue;\n        \}\n        float4 vec = alpha(j + x,i + y);\n        // Since its a white or black pixel, accessing one of the color channels \n        // is sufficient to determine if \n        // foreground or background\n        if(vec.x == 1 || vec.y == 1 || vec.z == 1) \{\n            numOnes +=1;\n        \}\n        else\{\n            numZeros +=1;\n        \}\n      \}\n    \}\n\n    float E_t = 60;\n\n    float E0 = E_t + lambda * float(numZeros);\n\n    float E1 = energy(x,y).x + lambda * float(numOnes);\n\n    if(E0 > E1)\n    \{\n      dst_alpha() = float4(0.0f,0.0f,0.0f,1.0f);\n    \}\n    else \n    \{\n      dst_alpha() = float4(1.0f,1.0f,1.0f,1.0f);\n    \}\n  \}\n\};\n"
 rebuild ""
 rebuild_finalise ""
 name MAP2
 xpos 57
 ypos -10
}
set N9388f800 [stack 0]
Read {
 inputs 0
 file_type tiff
 file "C:/Users/mradt/Documents/Trinity/Binary-Matting/Hula.MLKey.  ##.tiff"
 format "2048 1080 0 0 2048 1080 1 2K_DCP"
 first 46
 last 50
 origfirst 46
 origlast 50
 origset true
 name Read3
 xpos -477
 ypos -152
}
BlinkScript {
 inputs 2
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/EqualsTo.blink"
 recompileCount 8
 ProgramGroup 1
 KernelDescription "2 \"EqualsTo\" iterate pixelWise bcd1be60cea15d2194548ece8f665c5b1fc4d609d87773aaf7743543845fc1e4 3 \"src\" Read Point \"ref\" Read Point \"dst\" Write Point 0 0 0"
 kernelSource "kernel EqualsTo: ImageComputationKernel<ePixelWise> \{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image (binary)\n  Image<eRead, eAccessPoint, eEdgeClamped> ref; // the reference image\n  // Checks if differences between two images is more than 1e6\n  // If it is .. that pel is coloured RED, otherwise its GREEN\n\n  Image<eWrite> dst; // the output image\n  \n  // pos gives the position of the kernel in the output image\n  void process(int2 pos) \{\n    SampleType(dst) sample(0.0f);\n    SampleType(src) input = src();\n    SampleType(ref) ref_input = ref();\n    float error = fabs(input.x - ref_input.x);\n                   + fabs(input.y - ref_input.y)\n                   + fabs(input.z - ref_input.z);\n    if (error >0.000001)\n      sample.x = 1.0f;\n    else\n      sample.y = 1.0f;\n\n    dst() = sample;\n  \}\n\};"
 rebuild ""
 rebuild_finalise ""
 name BlinkScript2
 xpos -437
 ypos 58
}
Read {
 inputs 0
 file_type png
 file "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/Hula.Fore.ACKGT.00047.png"
 format "2048 1080 0 0 2048 1080 1 2K_DCP"
 origset true
 name Read6
 xpos -549
 ypos 166
}
set N938be400 [stack 0]
push $N93840800
Dot {
 name Dot6
 xpos 204
 ypos -274
}
set N938bec00 [stack 0]
TimeOffset {
 time_offset 1
 time ""
 name PreviousFrame
 xpos 170
 ypos -213
}
Expression {
 expr0 "(r - 0.3217) *(r - 0.3217) /0.00193"
 expr1 "(g-0.6276) * (g-0.6276)/0.00021"
 expr2 "(b - 0.5150) * (b - 0.5150) / 0.000251"
 name PreviousBE
 xpos 170
 ypos -189
}
Expression {
 expr0 "r + g + b"
 expr1 "r + g + b"
 expr2 "r + g + b"
 name MotionBESum
 xpos 170
 ypos -165
}
set N938bf400 [stack 0]
Expression {
 temp_name0 threshold
 temp_expr0 70
 expr0 "step(threshold, r)"
 expr1 "step(threshold, r)"
 expr2 "step(threshold, r)"
 name PreviousThreshold
 xpos 170
 ypos -92
}
push $N938bf400
Dot {
 name Dot16
 xpos 280
 ypos -162
}
set N938bfc00 [stack 0]
BlinkScript {
 inputs 2
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/MAP.rpp"
 recompileCount 98
 KernelDescription "2 \"MAP\" iterate pixelWise fd48645e1b4de5817c41d4e9dd78ad326a3255f342c03d4c0999d062c53eaedc 3 \"energy\" Read Random \"alpha\" Read Random \"dst_alpha\" Write Point 0 0 0"
 kernelSource "\nkernel MAP : ImageComputationKernel<ePixelWise>\n\{\n\n  Image<eRead, eAccessRandom, eEdgeClamped> energy; // the input background energy \n  Image<eRead, eAccessRandom, eEdgeClamped> alpha; // the referenced image\n\n\n  Image<eWrite> dst_alpha; // the output alpha\n\n\n  void process(int2 pos) \{\n    int x = pos.x;\n    int y = pos.y;\n\n    int numZeros = 0;\n    int numOnes = 0;\n    float lambda = 20.0f;\n    \n    // Calculate 3x3 neighborhood of pixels that say what we should be.\n    for(int i = -1; i < 2; i++) \{\n      for(int j = -1; j < 2; j++) \{\n        if(i == 0 && j == 0)\n        \{\n          continue;\n        \}\n        float4 vec = alpha(j + x,i + y);\n        // Since its a white or black pixel, accessing one of the color channels \n        // is sufficient to determine if \n        // foreground or background\n        if(vec.x == 1 || vec.y == 1 || vec.z == 1) \{\n            numOnes +=1;\n        \}\n        else\{\n            numZeros +=1;\n        \}\n      \}\n    \}\n\n    float E_t = 60;\n\n    float E0 = E_t + lambda * float(numZeros);\n\n    float E1 = energy(x,y).x + lambda * float(numOnes);\n\n    if(E0 > E1)\n    \{\n      dst_alpha() = float4(0.0f,0.0f,0.0f,1.0f);\n    \}\n    else \n    \{\n      dst_alpha() = float4(1.0f,1.0f,1.0f,1.0f);\n    \}\n  \}\n\};\n"
 rebuild ""
 rebuild_finalise ""
 name PreviousAlpha
 xpos 294
 ypos -212
}
set Nd75bc000 [stack 0]
BlinkScript {
 inputs 2
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/EqualsTo.blink"
 recompileCount 8
 ProgramGroup 1
 KernelDescription "2 \"EqualsTo\" iterate pixelWise bcd1be60cea15d2194548ece8f665c5b1fc4d609d87773aaf7743543845fc1e4 3 \"src\" Read Point \"ref\" Read Point \"dst\" Write Point 0 0 0"
 kernelSource "kernel EqualsTo: ImageComputationKernel<ePixelWise> \{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image (binary)\n  Image<eRead, eAccessPoint, eEdgeClamped> ref; // the reference image\n  // Checks if differences between two images is more than 1e6\n  // If it is .. that pel is coloured RED, otherwise its GREEN\n\n  Image<eWrite> dst; // the output image\n  \n  // pos gives the position of the kernel in the output image\n  void process(int2 pos) \{\n    SampleType(dst) sample(0.0f);\n    SampleType(src) input = src();\n    SampleType(ref) ref_input = ref();\n    float error = fabs(input.x - ref_input.x);\n                   + fabs(input.y - ref_input.y)\n                   + fabs(input.z - ref_input.z);\n    if (error >0.000001)\n      sample.x = 1.0f;\n    else\n      sample.y = 1.0f;\n\n    dst() = sample;\n  \}\n\};"
 rebuild ""
 rebuild_finalise ""
 name BlinkScript6
 xpos -254
 ypos 305
}
push $N938be400
push $Nd75bc000
push $N938bfc00
BlinkScript {
 inputs 2
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/MAP.rpp"
 recompileCount 98
 KernelDescription "2 \"MAP\" iterate pixelWise fd48645e1b4de5817c41d4e9dd78ad326a3255f342c03d4c0999d062c53eaedc 3 \"energy\" Read Random \"alpha\" Read Random \"dst_alpha\" Write Point 0 0 0"
 kernelSource "\nkernel MAP : ImageComputationKernel<ePixelWise>\n\{\n\n  Image<eRead, eAccessRandom, eEdgeClamped> energy; // the input background energy \n  Image<eRead, eAccessRandom, eEdgeClamped> alpha; // the referenced image\n\n\n  Image<eWrite> dst_alpha; // the output alpha\n\n\n  void process(int2 pos) \{\n    int x = pos.x;\n    int y = pos.y;\n\n    int numZeros = 0;\n    int numOnes = 0;\n    float lambda = 20.0f;\n    \n    // Calculate 3x3 neighborhood of pixels that say what we should be.\n    for(int i = -1; i < 2; i++) \{\n      for(int j = -1; j < 2; j++) \{\n        if(i == 0 && j == 0)\n        \{\n          continue;\n        \}\n        float4 vec = alpha(j + x,i + y);\n        // Since its a white or black pixel, accessing one of the color channels \n        // is sufficient to determine if \n        // foreground or background\n        if(vec.x == 1 || vec.y == 1 || vec.z == 1) \{\n            numOnes +=1;\n        \}\n        else\{\n            numZeros +=1;\n        \}\n      \}\n    \}\n\n    float E_t = 60;\n\n    float E0 = E_t + lambda * float(numZeros);\n\n    float E1 = energy(x,y).x + lambda * float(numOnes);\n\n    if(E0 > E1)\n    \{\n      dst_alpha() = float4(0.0f,0.0f,0.0f,1.0f);\n    \}\n    else \n    \{\n      dst_alpha() = float4(1.0f,1.0f,1.0f,1.0f);\n    \}\n  \}\n\};\n"
 rebuild ""
 rebuild_finalise ""
 name PreviousAlpha1
 xpos 294
 ypos -162
}
set Nd75bc800 [stack 0]
BlinkScript {
 inputs 2
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/EqualsTo.blink"
 recompileCount 8
 ProgramGroup 1
 KernelDescription "2 \"EqualsTo\" iterate pixelWise bcd1be60cea15d2194548ece8f665c5b1fc4d609d87773aaf7743543845fc1e4 3 \"src\" Read Point \"ref\" Read Point \"dst\" Write Point 0 0 0"
 kernelSource "kernel EqualsTo: ImageComputationKernel<ePixelWise> \{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image (binary)\n  Image<eRead, eAccessPoint, eEdgeClamped> ref; // the reference image\n  // Checks if differences between two images is more than 1e6\n  // If it is .. that pel is coloured RED, otherwise its GREEN\n\n  Image<eWrite> dst; // the output image\n  \n  // pos gives the position of the kernel in the output image\n  void process(int2 pos) \{\n    SampleType(dst) sample(0.0f);\n    SampleType(src) input = src();\n    SampleType(ref) ref_input = ref();\n    float error = fabs(input.x - ref_input.x);\n                   + fabs(input.y - ref_input.y)\n                   + fabs(input.z - ref_input.z);\n    if (error >0.000001)\n      sample.x = 1.0f;\n    else\n      sample.y = 1.0f;\n\n    dst() = sample;\n  \}\n\};"
 rebuild ""
 rebuild_finalise ""
 name BlinkScript7
 xpos -251
 ypos 362
}
push $Nd75bc800
push $N938bfc00
BlinkScript {
 inputs 2
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/MAP.rpp"
 recompileCount 98
 KernelDescription "2 \"MAP\" iterate pixelWise fd48645e1b4de5817c41d4e9dd78ad326a3255f342c03d4c0999d062c53eaedc 3 \"energy\" Read Random \"alpha\" Read Random \"dst_alpha\" Write Point 0 0 0"
 kernelSource "\nkernel MAP : ImageComputationKernel<ePixelWise>\n\{\n\n  Image<eRead, eAccessRandom, eEdgeClamped> energy; // the input background energy \n  Image<eRead, eAccessRandom, eEdgeClamped> alpha; // the referenced image\n\n\n  Image<eWrite> dst_alpha; // the output alpha\n\n\n  void process(int2 pos) \{\n    int x = pos.x;\n    int y = pos.y;\n\n    int numZeros = 0;\n    int numOnes = 0;\n    float lambda = 20.0f;\n    \n    // Calculate 3x3 neighborhood of pixels that say what we should be.\n    for(int i = -1; i < 2; i++) \{\n      for(int j = -1; j < 2; j++) \{\n        if(i == 0 && j == 0)\n        \{\n          continue;\n        \}\n        float4 vec = alpha(j + x,i + y);\n        // Since its a white or black pixel, accessing one of the color channels \n        // is sufficient to determine if \n        // foreground or background\n        if(vec.x == 1 || vec.y == 1 || vec.z == 1) \{\n            numOnes +=1;\n        \}\n        else\{\n            numZeros +=1;\n        \}\n      \}\n    \}\n\n    float E_t = 60;\n\n    float E0 = E_t + lambda * float(numZeros);\n\n    float E1 = energy(x,y).x + lambda * float(numOnes);\n\n    if(E0 > E1)\n    \{\n      dst_alpha() = float4(0.0f,0.0f,0.0f,1.0f);\n    \}\n    else \n    \{\n      dst_alpha() = float4(1.0f,1.0f,1.0f,1.0f);\n    \}\n  \}\n\};\n"
 rebuild ""
 rebuild_finalise ""
 name PreviousAlpha2
 xpos 294
 ypos -113
}
set Nd75bd000 [stack 0]
push $N938be400
BlinkScript {
 inputs 2
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/EqualsTo.blink"
 recompileCount 8
 ProgramGroup 1
 KernelDescription "2 \"EqualsTo\" iterate pixelWise bcd1be60cea15d2194548ece8f665c5b1fc4d609d87773aaf7743543845fc1e4 3 \"src\" Read Point \"ref\" Read Point \"dst\" Write Point 0 0 0"
 kernelSource "kernel EqualsTo: ImageComputationKernel<ePixelWise> \{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image (binary)\n  Image<eRead, eAccessPoint, eEdgeClamped> ref; // the reference image\n  // Checks if differences between two images is more than 1e6\n  // If it is .. that pel is coloured RED, otherwise its GREEN\n\n  Image<eWrite> dst; // the output image\n  \n  // pos gives the position of the kernel in the output image\n  void process(int2 pos) \{\n    SampleType(dst) sample(0.0f);\n    SampleType(src) input = src();\n    SampleType(ref) ref_input = ref();\n    float error = fabs(input.x - ref_input.x);\n                   + fabs(input.y - ref_input.y)\n                   + fabs(input.z - ref_input.z);\n    if (error >0.000001)\n      sample.x = 1.0f;\n    else\n      sample.y = 1.0f;\n\n    dst() = sample;\n  \}\n\};"
 rebuild ""
 rebuild_finalise ""
 name BlinkScript8
 xpos -251
 ypos 432
}
push $N938be400
push $N9388f800
BlinkScript {
 inputs 2
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/EqualsTo.blink"
 recompileCount 8
 ProgramGroup 1
 KernelDescription "2 \"EqualsTo\" iterate pixelWise bcd1be60cea15d2194548ece8f665c5b1fc4d609d87773aaf7743543845fc1e4 3 \"src\" Read Point \"ref\" Read Point \"dst\" Write Point 0 0 0"
 kernelSource "kernel EqualsTo: ImageComputationKernel<ePixelWise> \{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image (binary)\n  Image<eRead, eAccessPoint, eEdgeClamped> ref; // the reference image\n  // Checks if differences between two images is more than 1e6\n  // If it is .. that pel is coloured RED, otherwise its GREEN\n\n  Image<eWrite> dst; // the output image\n  \n  // pos gives the position of the kernel in the output image\n  void process(int2 pos) \{\n    SampleType(dst) sample(0.0f);\n    SampleType(src) input = src();\n    SampleType(ref) ref_input = ref();\n    float error = fabs(input.x - ref_input.x);\n                   + fabs(input.y - ref_input.y)\n                   + fabs(input.z - ref_input.z);\n    if (error >0.000001)\n      sample.x = 1.0f;\n    else\n      sample.y = 1.0f;\n\n    dst() = sample;\n  \}\n\};"
 rebuild ""
 rebuild_finalise ""
 name BlinkScript5
 xpos -261
 ypos 209
}
push $N9388f000
push $N938be400
BlinkScript {
 inputs 2
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/EqualsTo.blink"
 recompileCount 8
 ProgramGroup 1
 KernelDescription "2 \"EqualsTo\" iterate pixelWise bcd1be60cea15d2194548ece8f665c5b1fc4d609d87773aaf7743543845fc1e4 3 \"src\" Read Point \"ref\" Read Point \"dst\" Write Point 0 0 0"
 kernelSource "kernel EqualsTo: ImageComputationKernel<ePixelWise> \{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image (binary)\n  Image<eRead, eAccessPoint, eEdgeClamped> ref; // the reference image\n  // Checks if differences between two images is more than 1e6\n  // If it is .. that pel is coloured RED, otherwise its GREEN\n\n  Image<eWrite> dst; // the output image\n  \n  // pos gives the position of the kernel in the output image\n  void process(int2 pos) \{\n    SampleType(dst) sample(0.0f);\n    SampleType(src) input = src();\n    SampleType(ref) ref_input = ref();\n    float error = fabs(input.x - ref_input.x);\n                   + fabs(input.y - ref_input.y)\n                   + fabs(input.z - ref_input.z);\n    if (error >0.000001)\n      sample.x = 1.0f;\n    else\n      sample.y = 1.0f;\n\n    dst() = sample;\n  \}\n\};"
 rebuild ""
 rebuild_finalise ""
 name BlinkScript4
 xpos -254
 ypos 164
}
push $N9388e800
push $N938be400
BlinkScript {
 inputs 2
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/EqualsTo.blink"
 recompileCount 8
 ProgramGroup 1
 KernelDescription "2 \"EqualsTo\" iterate pixelWise bcd1be60cea15d2194548ece8f665c5b1fc4d609d87773aaf7743543845fc1e4 3 \"src\" Read Point \"ref\" Read Point \"dst\" Write Point 0 0 0"
 kernelSource "kernel EqualsTo: ImageComputationKernel<ePixelWise> \{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image (binary)\n  Image<eRead, eAccessPoint, eEdgeClamped> ref; // the reference image\n  // Checks if differences between two images is more than 1e6\n  // If it is .. that pel is coloured RED, otherwise its GREEN\n\n  Image<eWrite> dst; // the output image\n  \n  // pos gives the position of the kernel in the output image\n  void process(int2 pos) \{\n    SampleType(dst) sample(0.0f);\n    SampleType(src) input = src();\n    SampleType(ref) ref_input = ref();\n    float error = fabs(input.x - ref_input.x);\n                   + fabs(input.y - ref_input.y)\n                   + fabs(input.z - ref_input.z);\n    if (error >0.000001)\n      sample.x = 1.0f;\n    else\n      sample.y = 1.0f;\n\n    dst() = sample;\n  \}\n\};"
 rebuild ""
 rebuild_finalise ""
 name BlinkScript3
 xpos -254
 ypos 119
}
push $N938bec00
Dot {
 name Dot4
 xpos 500
 ypos -274
}
Dot {
 name Dot5
 xpos 729
 ypos -274
}
set Nd75bdc00 [stack 0]
TimeOffset {
 time_offset 1
 time ""
 name TimeOffset1
 xpos 695
 ypos -227
}
push $Nd75bd000
Dot {
 name Dot14
 xpos 328
 ypos -72
}
set Nd75fa000 [stack 0]
Dot {
 name Dot13
 xpos 328
 ypos 1
}
push $Nd75fa000
push $Nd75bd000
push $N9388e000
Dot {
 name Dot10
 xpos -30
 ypos -231
}
Dot {
 name Dot11
 xpos 496
 ypos -231
}
set Nd75fac00 [stack 0]
push $N9388e400
Dot {
 name Dot8
 xpos -11
 ypos -243
}
Dot {
 name Dot9
 xpos 439
 ypos -249
}
set Nd75fb400 [stack 0]
BlinkScript {
 inputs 3
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/MAP3D.rpp"
 recompileCount 12
 ProgramGroup 1
 KernelDescription "2 \"MAP\" iterate pixelWise 14b6edd4951f0dcdc518f4407fd85f9cd851bc90944238022dac2093ff1861c5 4 \"energy\" Read Random \"alpha\" Read Random \"previousAlpha\" Read Random \"dst_alpha\" Write Point 0 0 0"
 kernelSource "\nkernel MAP : ImageComputationKernel<ePixelWise>\n\{\n\n  Image<eRead, eAccessRandom, eEdgeClamped> energy; // the input background energy \n  Image<eRead, eAccessRandom, eEdgeClamped> alpha; // the referenced image\n  Image<eRead, eAccessRandom, eEdgeClamped> previousAlpha; // the referenced image\n\n\n  Image<eWrite> dst_alpha; // the output alpha\n\n\n  void process(int2 pos) \{\n    int x = pos.x;\n    int y = pos.y;\n\n    int numZeros = 0;\n    int numOnes = 0;\n    float lambda = 20.0f;\n    \n    // Calculate 3x3 neighborhood of pixels that say what we should be.\n    for(int i = -1; i < 2; i++) \{\n      for(int j = -1; j < 2; j++) \{\n        if(i == 0 && j == 0)\n        \{\n          continue;\n        \}\n        float4 vec = alpha(j + x,i + y);\n        // Since its a white or black pixel, accessing one of the color channels \n        // is sufficient to determine if \n        // foreground or background\n        if(vec.x == 1 || vec.y == 1 || vec.z == 1) \{\n            numOnes +=1;\n        \}\n        else\{\n            numZeros +=1;\n        \}\n      \}\n    \}\n\n    // Calculate 3x3 values of previous frame. Same code as before\n    for(int i = -1; i < 2; i++) \{\n      for(int j = -1; j < 2; j++) \{\n        float4 vec = previousAlpha(j + x,i + y);\n        if(vec.x == 1 || vec.y == 1 || vec.z == 1) \{\n            numOnes +=1;\n        \}\n        else\{\n            numZeros +=1;\n        \}\n      \}\n    \}\n\n    float E_t = 60;\n\n    float E0 = E_t + lambda * float(numZeros);\n\n    float E1 = energy(x,y).x + lambda * float(numOnes);\n\n    if(E0 > E1)\n    \{\n      dst_alpha() = float4(0.0f,0.0f,0.0f,1.0f);\n    \}\n    else \n    \{\n      dst_alpha() = float4(1.0f,1.0f,1.0f,1.0f);\n    \}\n  \}\n\};\n"
 rebuild ""
 rebuild_finalise ""
 name MAP3D
 xpos 462
 ypos -171
}
push $Nd75fb400
Dot {
 name Dot12
 xpos 439
 ypos -131
}
set Nd75fbc00 [stack 0]
BlinkScript {
 inputs 3
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/MAP3D.rpp"
 recompileCount 12
 ProgramGroup 1
 KernelDescription "2 \"MAP\" iterate pixelWise 14b6edd4951f0dcdc518f4407fd85f9cd851bc90944238022dac2093ff1861c5 4 \"energy\" Read Random \"alpha\" Read Random \"previousAlpha\" Read Random \"dst_alpha\" Write Point 0 0 0"
 kernelSource "\nkernel MAP : ImageComputationKernel<ePixelWise>\n\{\n\n  Image<eRead, eAccessRandom, eEdgeClamped> energy; // the input background energy \n  Image<eRead, eAccessRandom, eEdgeClamped> alpha; // the referenced image\n  Image<eRead, eAccessRandom, eEdgeClamped> previousAlpha; // the referenced image\n\n\n  Image<eWrite> dst_alpha; // the output alpha\n\n\n  void process(int2 pos) \{\n    int x = pos.x;\n    int y = pos.y;\n\n    int numZeros = 0;\n    int numOnes = 0;\n    float lambda = 20.0f;\n    \n    // Calculate 3x3 neighborhood of pixels that say what we should be.\n    for(int i = -1; i < 2; i++) \{\n      for(int j = -1; j < 2; j++) \{\n        if(i == 0 && j == 0)\n        \{\n          continue;\n        \}\n        float4 vec = alpha(j + x,i + y);\n        // Since its a white or black pixel, accessing one of the color channels \n        // is sufficient to determine if \n        // foreground or background\n        if(vec.x == 1 || vec.y == 1 || vec.z == 1) \{\n            numOnes +=1;\n        \}\n        else\{\n            numZeros +=1;\n        \}\n      \}\n    \}\n\n    // Calculate 3x3 values of previous frame. Same code as before\n    for(int i = -1; i < 2; i++) \{\n      for(int j = -1; j < 2; j++) \{\n        float4 vec = previousAlpha(j + x,i + y);\n        if(vec.x == 1 || vec.y == 1 || vec.z == 1) \{\n            numOnes +=1;\n        \}\n        else\{\n            numZeros +=1;\n        \}\n      \}\n    \}\n\n    float E_t = 60;\n\n    float E0 = E_t + lambda * float(numZeros);\n\n    float E1 = energy(x,y).x + lambda * float(numOnes);\n\n    if(E0 > E1)\n    \{\n      dst_alpha() = float4(0.0f,0.0f,0.0f,1.0f);\n    \}\n    else \n    \{\n      dst_alpha() = float4(1.0f,1.0f,1.0f,1.0f);\n    \}\n  \}\n\};\n"
 rebuild ""
 rebuild_finalise ""
 name MAP3D1
 xpos 462
 ypos -81
}
push $Nd75fbc00
Dot {
 name Dot15
 xpos 439
 ypos -30
}
BlinkScript {
 inputs 3
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/MAP3D.rpp"
 recompileCount 12
 ProgramGroup 1
 KernelDescription "2 \"MAP\" iterate pixelWise 14b6edd4951f0dcdc518f4407fd85f9cd851bc90944238022dac2093ff1861c5 4 \"energy\" Read Random \"alpha\" Read Random \"previousAlpha\" Read Random \"dst_alpha\" Write Point 0 0 0"
 kernelSource "\nkernel MAP : ImageComputationKernel<ePixelWise>\n\{\n\n  Image<eRead, eAccessRandom, eEdgeClamped> energy; // the input background energy \n  Image<eRead, eAccessRandom, eEdgeClamped> alpha; // the referenced image\n  Image<eRead, eAccessRandom, eEdgeClamped> previousAlpha; // the referenced image\n\n\n  Image<eWrite> dst_alpha; // the output alpha\n\n\n  void process(int2 pos) \{\n    int x = pos.x;\n    int y = pos.y;\n\n    int numZeros = 0;\n    int numOnes = 0;\n    float lambda = 20.0f;\n    \n    // Calculate 3x3 neighborhood of pixels that say what we should be.\n    for(int i = -1; i < 2; i++) \{\n      for(int j = -1; j < 2; j++) \{\n        if(i == 0 && j == 0)\n        \{\n          continue;\n        \}\n        float4 vec = alpha(j + x,i + y);\n        // Since its a white or black pixel, accessing one of the color channels \n        // is sufficient to determine if \n        // foreground or background\n        if(vec.x == 1 || vec.y == 1 || vec.z == 1) \{\n            numOnes +=1;\n        \}\n        else\{\n            numZeros +=1;\n        \}\n      \}\n    \}\n\n    // Calculate 3x3 values of previous frame. Same code as before\n    for(int i = -1; i < 2; i++) \{\n      for(int j = -1; j < 2; j++) \{\n        float4 vec = previousAlpha(j + x,i + y);\n        if(vec.x == 1 || vec.y == 1 || vec.z == 1) \{\n            numOnes +=1;\n        \}\n        else\{\n            numZeros +=1;\n        \}\n      \}\n    \}\n\n    float E_t = 60;\n\n    float E0 = E_t + lambda * float(numZeros);\n\n    float E1 = energy(x,y).x + lambda * float(numOnes);\n\n    if(E0 > E1)\n    \{\n      dst_alpha() = float4(0.0f,0.0f,0.0f,1.0f);\n    \}\n    else \n    \{\n      dst_alpha() = float4(1.0f,1.0f,1.0f,1.0f);\n    \}\n  \}\n\};\n"
 rebuild ""
 rebuild_finalise ""
 name MAP3D2
 xpos 462
 ypos -8
}
set Nd761c800 [stack 0]
push $Nd75bdc00
VectorGenerator {
 inputs 2
 Advanced 1
 name VectorGenerator1
 xpos 862
 ypos -283
}
ShuffleCopy {
 inputs 2
 in2 motion
 red red
 green green
 blue blue
 black blue2
 white alpha2
 out2 backward
 name ShuffleCopy1
 xpos 862
 ypos -227
}
IDistort {
 uv backward
 filter Simon
 name IDistort1
 xpos 862
 ypos -191
}
set Nd761d400 [stack 0]
push $Nd761c800
push $Nd761d400
Expression {
 expr0 "(r - 0.3217) *(r - 0.3217) /0.00193"
 expr1 "(g-0.6276) * (g-0.6276)/0.00021"
 expr2 "(b - 0.5150) * (b - 0.5150) / 0.000251"
 name BEMotion
 xpos 862
 ypos -142
}
Expression {
 expr0 "r + g + b"
 expr1 "r + g + b"
 expr2 "r + g + b"
 name PreviousBESum1
 xpos 862
 ypos -106
}
Expression {
 temp_name0 threshold
 temp_expr0 70
 expr0 "step(threshold, r)"
 expr1 "step(threshold, r)"
 expr2 "step(threshold, r)"
 name ThresholdMotionEnergy
 xpos 862
 ypos -55
}
set N83fffc00 [stack 0]
push $N83fffc00
push $N83fffc00
push $Nd75fac00
push $Nd75fb400
Dot {
 name Dot17
 xpos 1043
 ypos -249
}
set N83ffe800 [stack 0]
BlinkScript {
 inputs 3
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/MAP3D.rpp"
 recompileCount 12
 ProgramGroup 1
 KernelDescription "2 \"MAP\" iterate pixelWise 14b6edd4951f0dcdc518f4407fd85f9cd851bc90944238022dac2093ff1861c5 4 \"energy\" Read Random \"alpha\" Read Random \"previousAlpha\" Read Random \"dst_alpha\" Write Point 0 0 0"
 kernelSource "\nkernel MAP : ImageComputationKernel<ePixelWise>\n\{\n\n  Image<eRead, eAccessRandom, eEdgeClamped> energy; // the input background energy \n  Image<eRead, eAccessRandom, eEdgeClamped> alpha; // the referenced image\n  Image<eRead, eAccessRandom, eEdgeClamped> previousAlpha; // the referenced image\n\n\n  Image<eWrite> dst_alpha; // the output alpha\n\n\n  void process(int2 pos) \{\n    int x = pos.x;\n    int y = pos.y;\n\n    int numZeros = 0;\n    int numOnes = 0;\n    float lambda = 20.0f;\n    \n    // Calculate 3x3 neighborhood of pixels that say what we should be.\n    for(int i = -1; i < 2; i++) \{\n      for(int j = -1; j < 2; j++) \{\n        if(i == 0 && j == 0)\n        \{\n          continue;\n        \}\n        float4 vec = alpha(j + x,i + y);\n        // Since its a white or black pixel, accessing one of the color channels \n        // is sufficient to determine if \n        // foreground or background\n        if(vec.x == 1 || vec.y == 1 || vec.z == 1) \{\n            numOnes +=1;\n        \}\n        else\{\n            numZeros +=1;\n        \}\n      \}\n    \}\n\n    // Calculate 3x3 values of previous frame. Same code as before\n    for(int i = -1; i < 2; i++) \{\n      for(int j = -1; j < 2; j++) \{\n        float4 vec = previousAlpha(j + x,i + y);\n        if(vec.x == 1 || vec.y == 1 || vec.z == 1) \{\n            numOnes +=1;\n        \}\n        else\{\n            numZeros +=1;\n        \}\n      \}\n    \}\n\n    float E_t = 60;\n\n    float E0 = E_t + lambda * float(numZeros);\n\n    float E1 = energy(x,y).x + lambda * float(numOnes);\n\n    if(E0 > E1)\n    \{\n      dst_alpha() = float4(0.0f,0.0f,0.0f,1.0f);\n    \}\n    else \n    \{\n      dst_alpha() = float4(1.0f,1.0f,1.0f,1.0f);\n    \}\n  \}\n\};\n"
 rebuild ""
 rebuild_finalise ""
 name MAP3D3
 xpos 1086
 ypos -240
}
set N83fff400 [stack 0]
push $N83ffe800
Dot {
 name Dot18
 xpos 1043
 ypos -141
}
set N83ffe400 [stack 0]
BlinkScript {
 inputs 3
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/MAP3D.rpp"
 recompileCount 12
 ProgramGroup 1
 KernelDescription "2 \"MAP\" iterate pixelWise 14b6edd4951f0dcdc518f4407fd85f9cd851bc90944238022dac2093ff1861c5 4 \"energy\" Read Random \"alpha\" Read Random \"previousAlpha\" Read Random \"dst_alpha\" Write Point 0 0 0"
 kernelSource "\nkernel MAP : ImageComputationKernel<ePixelWise>\n\{\n\n  Image<eRead, eAccessRandom, eEdgeClamped> energy; // the input background energy \n  Image<eRead, eAccessRandom, eEdgeClamped> alpha; // the referenced image\n  Image<eRead, eAccessRandom, eEdgeClamped> previousAlpha; // the referenced image\n\n\n  Image<eWrite> dst_alpha; // the output alpha\n\n\n  void process(int2 pos) \{\n    int x = pos.x;\n    int y = pos.y;\n\n    int numZeros = 0;\n    int numOnes = 0;\n    float lambda = 20.0f;\n    \n    // Calculate 3x3 neighborhood of pixels that say what we should be.\n    for(int i = -1; i < 2; i++) \{\n      for(int j = -1; j < 2; j++) \{\n        if(i == 0 && j == 0)\n        \{\n          continue;\n        \}\n        float4 vec = alpha(j + x,i + y);\n        // Since its a white or black pixel, accessing one of the color channels \n        // is sufficient to determine if \n        // foreground or background\n        if(vec.x == 1 || vec.y == 1 || vec.z == 1) \{\n            numOnes +=1;\n        \}\n        else\{\n            numZeros +=1;\n        \}\n      \}\n    \}\n\n    // Calculate 3x3 values of previous frame. Same code as before\n    for(int i = -1; i < 2; i++) \{\n      for(int j = -1; j < 2; j++) \{\n        float4 vec = previousAlpha(j + x,i + y);\n        if(vec.x == 1 || vec.y == 1 || vec.z == 1) \{\n            numOnes +=1;\n        \}\n        else\{\n            numZeros +=1;\n        \}\n      \}\n    \}\n\n    float E_t = 60;\n\n    float E0 = E_t + lambda * float(numZeros);\n\n    float E1 = energy(x,y).x + lambda * float(numOnes);\n\n    if(E0 > E1)\n    \{\n      dst_alpha() = float4(0.0f,0.0f,0.0f,1.0f);\n    \}\n    else \n    \{\n      dst_alpha() = float4(1.0f,1.0f,1.0f,1.0f);\n    \}\n  \}\n\};\n"
 rebuild ""
 rebuild_finalise ""
 name MAP3D4
 xpos 1086
 ypos -150
}
set N83fff000 [stack 0]
push $N83ffe400
BlinkScript {
 inputs 3
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/MAP3D.rpp"
 recompileCount 12
 ProgramGroup 1
 KernelDescription "2 \"MAP\" iterate pixelWise 14b6edd4951f0dcdc518f4407fd85f9cd851bc90944238022dac2093ff1861c5 4 \"energy\" Read Random \"alpha\" Read Random \"previousAlpha\" Read Random \"dst_alpha\" Write Point 0 0 0"
 kernelSource "\nkernel MAP : ImageComputationKernel<ePixelWise>\n\{\n\n  Image<eRead, eAccessRandom, eEdgeClamped> energy; // the input background energy \n  Image<eRead, eAccessRandom, eEdgeClamped> alpha; // the referenced image\n  Image<eRead, eAccessRandom, eEdgeClamped> previousAlpha; // the referenced image\n\n\n  Image<eWrite> dst_alpha; // the output alpha\n\n\n  void process(int2 pos) \{\n    int x = pos.x;\n    int y = pos.y;\n\n    int numZeros = 0;\n    int numOnes = 0;\n    float lambda = 20.0f;\n    \n    // Calculate 3x3 neighborhood of pixels that say what we should be.\n    for(int i = -1; i < 2; i++) \{\n      for(int j = -1; j < 2; j++) \{\n        if(i == 0 && j == 0)\n        \{\n          continue;\n        \}\n        float4 vec = alpha(j + x,i + y);\n        // Since its a white or black pixel, accessing one of the color channels \n        // is sufficient to determine if \n        // foreground or background\n        if(vec.x == 1 || vec.y == 1 || vec.z == 1) \{\n            numOnes +=1;\n        \}\n        else\{\n            numZeros +=1;\n        \}\n      \}\n    \}\n\n    // Calculate 3x3 values of previous frame. Same code as before\n    for(int i = -1; i < 2; i++) \{\n      for(int j = -1; j < 2; j++) \{\n        float4 vec = previousAlpha(j + x,i + y);\n        if(vec.x == 1 || vec.y == 1 || vec.z == 1) \{\n            numOnes +=1;\n        \}\n        else\{\n            numZeros +=1;\n        \}\n      \}\n    \}\n\n    float E_t = 60;\n\n    float E0 = E_t + lambda * float(numZeros);\n\n    float E1 = energy(x,y).x + lambda * float(numOnes);\n\n    if(E0 > E1)\n    \{\n      dst_alpha() = float4(0.0f,0.0f,0.0f,1.0f);\n    \}\n    else \n    \{\n      dst_alpha() = float4(1.0f,1.0f,1.0f,1.0f);\n    \}\n  \}\n\};\n"
 rebuild ""
 rebuild_finalise ""
 name MAP3D5
 xpos 1086
 ypos -77
}
set N83ffec00 [stack 0]
push $N83fff000
push $N83fff400
push $N83ffec00
Read {
 inputs 0
 file_type png
 file "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/Hula.Fore.ACKGT.00047.png"
 format "2048 1080 0 0 2048 1080 1 2K_DCP"
 origset true
 name Read4
 xpos 1180
 ypos 143
}
set Nfe0b0000 [stack 0]
BlinkScript {
 inputs 2
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/EqualsTo.blink"
 recompileCount 8
 ProgramGroup 1
 KernelDescription "2 \"EqualsTo\" iterate pixelWise bcd1be60cea15d2194548ece8f665c5b1fc4d609d87773aaf7743543845fc1e4 3 \"src\" Read Point \"ref\" Read Point \"dst\" Write Point 0 0 0"
 kernelSource "kernel EqualsTo: ImageComputationKernel<ePixelWise> \{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image (binary)\n  Image<eRead, eAccessPoint, eEdgeClamped> ref; // the reference image\n  // Checks if differences between two images is more than 1e6\n  // If it is .. that pel is coloured RED, otherwise its GREEN\n\n  Image<eWrite> dst; // the output image\n  \n  // pos gives the position of the kernel in the output image\n  void process(int2 pos) \{\n    SampleType(dst) sample(0.0f);\n    SampleType(src) input = src();\n    SampleType(ref) ref_input = ref();\n    float error = fabs(input.x - ref_input.x);\n                   + fabs(input.y - ref_input.y)\n                   + fabs(input.z - ref_input.z);\n    if (error >0.000001)\n      sample.x = 1.0f;\n    else\n      sample.y = 1.0f;\n\n    dst() = sample;\n  \}\n\};"
 rebuild ""
 rebuild_finalise ""
 name BlinkScript11
 xpos 939
 ypos 206
}
push $N83fff000
push $Nfe0b0000
BlinkScript {
 inputs 2
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/EqualsTo.blink"
 recompileCount 8
 ProgramGroup 1
 KernelDescription "2 \"EqualsTo\" iterate pixelWise bcd1be60cea15d2194548ece8f665c5b1fc4d609d87773aaf7743543845fc1e4 3 \"src\" Read Point \"ref\" Read Point \"dst\" Write Point 0 0 0"
 kernelSource "kernel EqualsTo: ImageComputationKernel<ePixelWise> \{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image (binary)\n  Image<eRead, eAccessPoint, eEdgeClamped> ref; // the reference image\n  // Checks if differences between two images is more than 1e6\n  // If it is .. that pel is coloured RED, otherwise its GREEN\n\n  Image<eWrite> dst; // the output image\n  \n  // pos gives the position of the kernel in the output image\n  void process(int2 pos) \{\n    SampleType(dst) sample(0.0f);\n    SampleType(src) input = src();\n    SampleType(ref) ref_input = ref();\n    float error = fabs(input.x - ref_input.x);\n                   + fabs(input.y - ref_input.y)\n                   + fabs(input.z - ref_input.z);\n    if (error >0.000001)\n      sample.x = 1.0f;\n    else\n      sample.y = 1.0f;\n\n    dst() = sample;\n  \}\n\};"
 rebuild ""
 rebuild_finalise ""
 name BlinkScript10
 xpos 939
 ypos 136
}
push $Nfe0b0000
push $N83fff400
BlinkScript {
 inputs 2
 kernelSourceFile "C:/Users/Matt/Documents/Trinity/Motion Picture Engineering/Assignment 1/EqualsTo.blink"
 recompileCount 8
 ProgramGroup 1
 KernelDescription "2 \"EqualsTo\" iterate pixelWise bcd1be60cea15d2194548ece8f665c5b1fc4d609d87773aaf7743543845fc1e4 3 \"src\" Read Point \"ref\" Read Point \"dst\" Write Point 0 0 0"
 kernelSource "kernel EqualsTo: ImageComputationKernel<ePixelWise> \{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image (binary)\n  Image<eRead, eAccessPoint, eEdgeClamped> ref; // the reference image\n  // Checks if differences between two images is more than 1e6\n  // If it is .. that pel is coloured RED, otherwise its GREEN\n\n  Image<eWrite> dst; // the output image\n  \n  // pos gives the position of the kernel in the output image\n  void process(int2 pos) \{\n    SampleType(dst) sample(0.0f);\n    SampleType(src) input = src();\n    SampleType(ref) ref_input = ref();\n    float error = fabs(input.x - ref_input.x);\n                   + fabs(input.y - ref_input.y)\n                   + fabs(input.z - ref_input.z);\n    if (error >0.000001)\n      sample.x = 1.0f;\n    else\n      sample.y = 1.0f;\n\n    dst() = sample;\n  \}\n\};"
 rebuild ""
 rebuild_finalise ""
 name BlinkScript9
 xpos 936
 ypos 79
}
Viewer {
 inputs 8
 frame_range 46-50
 input_number 2
 monitorOutOutputTransform rec709
 name Viewer1
 selected true
 xpos 352
 ypos 201
}
